<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>rancher2.0与k8s</title>
      <link href="/2018/06/04/rancher2-0%E4%B8%8Ek8s/"/>
      <url>/2018/06/04/rancher2-0%E4%B8%8Ek8s/</url>
      <content type="html"><![CDATA[<h1 id="k8s与rancher"><a href="#k8s与rancher" class="headerlink" title="k8s与rancher"></a>k8s与rancher</h1><p>在这几天里面，我做了下面的事情。</p><p>1.使用rancher1.6 基于cattle搭建，并用docker-compose部署应用。</p><p>2.使用rancher1.6 搭建k8s，并用kubectl 工具部署应用</p><p>3.使用rancher2.0 搭建k8s ，并用kubectl 工具部署应用。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul><li><p>容器是一种运行一个或者一组进程的方法，并且进程之间相互隔离</p></li><li><p>每个容器有自己的资源</p><ul><li>Pid,user,uts,mount point,network stack,etc</li><li>own view fo fileSystem</li></ul></li><li><p>Very similar to vms</p><ul><li>但是是基于线程，只跑应用，没有其他的</li><li>没有操作系统，只是Linux内核文件</li></ul></li><li><p>Benefits</p><ul><li><p>Smaller footPrint (只有应用的文件)</p></li><li><p>启动速度快，毫秒级别</p></li></ul></li><li><p>容器和虚拟机最大的区别 </p><ul><li>每个虚拟机内实际上都运行着一个完成的操作系统，容器共享了底层操作系统内核 </li></ul></li></ul><h2 id="开源容器编排技术"><a href="#开源容器编排技术" class="headerlink" title="开源容器编排技术"></a>开源容器编排技术</h2><ul><li>rancher cattle</li><li>Docker Swarm</li><li>Kubernetes</li><li>Marathon</li></ul><h2 id="cattle与k8s的差异"><a href="#cattle与k8s的差异" class="headerlink" title="cattle与k8s的差异"></a>cattle与k8s的差异</h2><p>下面是我认为差异会比较大的地方。</p><ul><li><p>最小单位</p><p>rancher最小单位为容器</p><p>k8s最小的单位为pod，由一个或多个共享存储／网络的容器组成。基本上一个服务就是一个pod，对外提供职责单一的服务，由一个container提供，还可以有一些其他contaner提供一些非关键服务，比如日志收集，数据备份等，像sidekick</p></li><li><p>Docker-compose,rancher-compose   -&gt; k8s.yaml</p><p>e.g</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br><span class="hljs-attr">  name:</span> <span class="hljs-string">redis-master</span><br><span class="hljs-attr">  labels:</span><br><span class="hljs-attr">    name:</span> <span class="hljs-string">redis-master</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">  replicas:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">  selector:</span><br><span class="hljs-attr">    name:</span> <span class="hljs-string">redis-master</span><br><span class="hljs-attr">  template:</span><br><span class="hljs-attr">    metadata:</span><br><span class="hljs-attr">     labels:</span><br><span class="hljs-attr">       name:</span> <span class="hljs-string">redis-master</span><br><span class="hljs-attr">    spec:</span><br><span class="hljs-attr">      containers:</span><br><span class="hljs-attr">      - name:</span> <span class="hljs-string">master</span><br><span class="hljs-attr">        image:</span> <span class="hljs-string">kubeguide/redis-master</span><br><span class="hljs-attr">        ports:</span><br><span class="hljs-attr">        - containerPort:</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>​</p></li><li><p>Catalog</p><p>k8s里面不仅有catalog,还有service catalog，对标cloud foundry的service broker。</p></li><li><p>负载均衡</p><p>rancher是使用的haproxy</p><p>k8s很灵活的可以使用nginx + ingres的addon，或外部云服务商提供的服务，例如ELB之类的</p></li></ul><h2 id="rancher1-6-升级到rancher2-0"><a href="#rancher1-6-升级到rancher2-0" class="headerlink" title="rancher1.6 升级到rancher2.0"></a>rancher1.6 升级到rancher2.0</h2><p>k8s是一个容器编排工具，rancher是一个基于容器编排系统的平台，类似于一个Paas平台。</p><p>rancher1.6还支持很多其他容器编排工具，rancher2.0开始，rancher开始向k8s的upstream发展，即rancher以后里面容器编排只支持k8s。</p><p>rancher官方F&amp;Q</p><p><img src="/Users/sunhui/Desktop/屏幕快照 2018-06-03 下午5.57.19.png" alt="屏幕快照 2018-06-03 下午5.57.19"></p><h3 id="Paas平台"><a href="#Paas平台" class="headerlink" title="Paas平台"></a>Paas平台</h3><p>1.搭建一个PaaS平台，围绕kubernets的生态，周边还有许多功能需要完善。</p><p><img src="/Users/sunhui/Desktop/屏幕快照 2018-06-01 下午3.13.45.png" alt="屏幕快照 2018-06-01 下午3.13.45"></p><p>2.搭建，维护，升级kubernets是比较麻烦的一件事情。rancher提供了RKE的一个安装工具，以及升级升级方案。</p><p>3.rancher2.0在基于kubernets的容器编排技术上面，提供了</p><ul><li>多种网络方案选择</li><li>监控和日志的集成</li><li>提供了一个基于HAProxy的LoadBalancer的选择。</li></ul><h3 id="rancher1-6到2-0-术语及概念变化对比"><a href="#rancher1-6到2-0-术语及概念变化对比" class="headerlink" title="rancher1.6到2.0 术语及概念变化对比"></a>rancher1.6到2.0 术语及概念变化对比</h3><ul><li>Host -&gt; cluster</li><li>Stack -&gt; namespace</li><li>service -&gt; workload</li><li>新增概念：Project (a set of namespaces) ，可以权限管理，使用canned网络策略可以实现project之间的网络隔离。后面的版本可以实现更多网络方案去实现网络隔离。</li></ul><h3 id="rancher1-6升级到2-0"><a href="#rancher1-6升级到2-0" class="headerlink" title="rancher1.6升级到2.0"></a>rancher1.6升级到2.0</h3><ul><li>rancher官方不支持1.6直接升级到2.0，需要重新搭建新的环境。</li><li>2.0不再支持rancher-compose,需要全部转换成k8s支持的的yaml</li></ul><h3 id="rancher2-0-三种节点类型"><a href="#rancher2-0-三种节点类型" class="headerlink" title="rancher2.0 三种节点类型"></a>rancher2.0 三种节点类型</h3><ul><li>Etcd node</li><li>Control Plane Nodes (master)<ul><li>API server</li><li>scheduler</li><li>controller manager</li></ul></li><li>Worker Nodes (node)<ul><li>kubelet</li><li>workload</li><li>ingress </li></ul></li></ul><h2 id="k8s的概念"><a href="#k8s的概念" class="headerlink" title="k8s的概念"></a>k8s的概念</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>具体请查看<a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">中文文档</a></p><h3 id="kubernets-运行时"><a href="#kubernets-运行时" class="headerlink" title="kubernets 运行时"></a>kubernets 运行时</h3><p><img src="/Users/sunhui/Desktop/屏幕快照 2018-05-31 下午5.04.21.png" alt="屏幕快照 2018-05-31 下午5.04.21"></p><h3 id="kubelet-运行时"><a href="#kubelet-运行时" class="headerlink" title="kubelet 运行时"></a>kubelet 运行时</h3><p><img src="/Users/sunhui/Desktop/屏幕快照 2018-05-31 下午5.26.13.png" alt="屏幕快照 2018-05-31 下午5.26.13"></p><h3 id="容器的调度"><a href="#容器的调度" class="headerlink" title="容器的调度"></a>容器的调度</h3><p>​    <a href="https://www.kubernetes.org.cn/1613.html" target="_blank" rel="noopener"> k8s调度</a></p><ul><li>Predicates<ul><li>PodFitPorts：没有任何端口冲突</li><li>PodFitsResurce：有足够的资源运行Pod</li><li>NoDiskConflict：有足够的空间来满足Pod和链接的数据卷</li><li>MatchNodeSelector：能够匹配Pod中的选择器查找参数。</li><li>HostName：能够匹配Pod中的Host参数</li></ul></li><li>Priorities<ul><li>LeastRequestdPriority：计算Pods需要的CPU和内存在当前节点可用资源的百分比，具有最小百分比的节点就是最优的。</li><li>BalanceResourceAllocation：拥有类似内存和CPU使用的节点。</li><li>ServicesSpreadingPriority：优先选择拥有不同Pods的节点。</li><li>EqualPriority：给所有集群的节点同样的优先级，仅仅是为了做测试。</li></ul></li></ul><h3 id="Labels-and-Selectors"><a href="#Labels-and-Selectors" class="headerlink" title="Labels and Selectors"></a>Labels and Selectors</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&quot;metadata&quot;: &#123;<br>  &quot;labels&quot;: &#123;<br>    &quot;key1&quot; : &quot;value1&quot;,<br>    &quot;key2&quot; : &quot;value2&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="—-使用场景"><a href="#—-使用场景" class="headerlink" title="— 使用场景"></a>— 使用场景</h4><ul><li>kube-controller监控的Pod副本的数量，从而实现Pod副本的数量始终符合预期</li><li>Service的均衡机制</li><li>NodeSelector实现Pod定向Node调度的特性</li></ul><h3 id="service-type"><a href="#service-type" class="headerlink" title="service type"></a>service type</h3><ul><li>ClusterIP</li></ul><ul><li>Nodeport</li><li>LoadBalancer</li></ul><h3 id="k8d里面的三种IP"><a href="#k8d里面的三种IP" class="headerlink" title="k8d里面的三种IP"></a>k8d里面的三种IP</h3><ul><li>Pod IP</li><li>Cluster IP</li><li>Node Port</li></ul><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><ul><li>环境变量</li><li>dns</li></ul><h3 id="volumn"><a href="#volumn" class="headerlink" title="volumn"></a>volumn</h3><p>Volume的生命周期比Pod中运行的任何容器要持久，在容器重新启动时能可以保留数据</p><ul><li>PV</li><li>PVC</li><li>Storage Class</li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Provisioning ——-&gt; Binding ——–&gt;Using——&gt;Releasing——&gt;Recycling</p><h4 id="Access-Modes"><a href="#Access-Modes" class="headerlink" title="Access Modes"></a>Access Modes</h4><ul><li>Single Node Read-Write </li><li>Many Nodes Read-Only </li><li>Many Nodes Read-Write</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>Rancher2.0 最开始只支持 Calico, Canal, and Flannel.</p><ul><li>Flannel,k8s默认的网络接入方案。overlay模型，把所有容器打通成一个扁平的网络，需要对IP进行封装，再传输看，效率一般，无法进行隔离。</li><li>calico 三层网络，可以把容器和外部网络打通，通过linux kernel对包进行转发，效率高，可以实现不同应用，不同租户之间的隔离。</li><li>Canal 就提供了将 Flannel 和 Calico组合的方案。可以提供network policy controller，实现网络的隔离。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>myFirst</title>
      <link href="/2018/05/23/myFirst/"/>
      <url>/2018/05/23/myFirst/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>My New Post</title>
      <link href="/2018/05/23/My-New-Post/"/>
      <url>/2018/05/23/My-New-Post/</url>
      <content type="html"><![CDATA[<p>helloworld</p>]]></content>
      
      
        <tags>
            
            <tag> helloworld </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/23/hello-world/"/>
      <url>/2018/05/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
    
  
</search>
